/* eslint-disable one-var */

'use strict';

Object.defineProperty(exports, '__esModule', {
  value: true
});

var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) arr2[i] = arr[i]; return arr2; } else { return Array.from(arr); } }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }

var _cache = require('./cache');

var _cache2 = _interopRequireDefault(_cache);

var _ampIsEmpty = require('amp-is-empty');

var _ampIsEmpty2 = _interopRequireDefault(_ampIsEmpty);

var _libGoogleGeocoder = require('./lib/google-geocoder');

var _libGoogleGeocoder2 = _interopRequireDefault(_libGoogleGeocoder);

var _errors = require('./errors');

var _errors2 = _interopRequireDefault(_errors);

var _defaults = require('./defaults');

var _defaults2 = _interopRequireDefault(_defaults);

var geocoderDefaults = {
  clientId: null,
  privateKey: null,
  apiKey: null,
  queriesPerSecond: _defaults2['default'].defaultQueriesPerSecond,
  maxRetries: _defaults2['default'].maxRetries
};

/**
 * Validate a Geocoder options object
 * This function throws an exception if the options are invalid
 * @param {Object} options The options object to be validated
 */
function validateOptions(options) {
  // eslint-disable-line complexity
  if ((options.clientId || options.privateKey) && options.apiKey) {
    throw new Error('Can only specify credentials or API key');
  }

  if (options.clientId && !options.privateKey) {
    throw new Error('Missing privateKey');
  }

  if (!options.clientId && options.privateKey) {
    throw new Error('Missing clientId');
  }

  if (!options.apiKey && !(options.clientId && options.privateKey)) {
    throw new Error('Must either provide credentials or API key');
  }

  if (options.queriesPerSecond < _defaults2['default'].minQueriesPerSecond || options.queriesPerSecond > _defaults2['default'].maxQueriesPerSecond) {
    throw new Error('Requests per second must be >= 1 and <= 50');
  }
}

/**
 * Geocoder instance
 * @type {Class}
 * @param {Object} options The options for the Geocoder
 */

var Geocoder = (function () {
  /**
   * Constructs a geocoder.
   * @param {Object} options Geocoder options.
   * @param {Object} geocoder The Google geocoding API class
   * @param {Object} GeoCache The Cache class
   */

  function Geocoder() {
    var options = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];
    var geocoder = arguments.length <= 1 || arguments[1] === undefined ? _libGoogleGeocoder2['default'] : arguments[1];
    var GeoCache = arguments.length <= 2 || arguments[2] === undefined ? _cache2['default'] : arguments[2];

    _classCallCheck(this, Geocoder);

    options = Object.assign({}, geocoderDefaults, options);
    validateOptions(options);

    this.queriesPerSecond = options.queriesPerSecond;
    this.maxRetries = options.maxRetries;
    this.queries = -1;
    this.queue = [];

    this.cache = new GeoCache(options.cacheFile);
    this.geocoder = geocoder.init({
      google_client_id: options.clientId, // eslint-disable-line camelcase
      google_private_key: options.privateKey, // eslint-disable-line camelcase
      key: options.apiKey
    });
  }

  /**
   * Geocode a single address
   * @param {String} address The address to geocode
   * @return {Promise} The promise
   */

  _createClass(Geocoder, [{
    key: 'geocodeAddress',
    value: function geocodeAddress(address) {
      var _this = this;

      return new Promise(function (resolve, reject) {
        _this.queueGeocode(address, resolve, reject);
      });
    }

    /**
     * Add a geocoding operation to the queue of geocodes
     * @param {String} address The address to geocode
     * @param {Function} resolve The Promise resolve function
     * @param {Function} reject The Promise reject function
     * @param {Number} retries The number of times this query has been tried
     * @return {?} Something to get out
     */
  }, {
    key: 'queueGeocode',
    value: function queueGeocode(address, resolve, reject) {
      var retries = arguments.length <= 3 || arguments[3] === undefined ? 0 : arguments[3];

      var cachedAddress = this.cache.get(address);
      if (cachedAddress) {
        return resolve(cachedAddress);
      }

      if (this.queries === -1) {
        this.startBucket();
      } else if (this.queries >= this.queriesPerSecond) {
        // maximum number of queries for this bucket exceeded
        return this.queue.push([address, resolve, reject, retries]);
      }

      this.queries++;
      this.startGeocode(address, resolve, reject, retries);
      return null;
    }

    /**
     * Reset query count and start a timeout of 1 second for this bucket
     **/
  }, {
    key: 'startBucket',
    value: function startBucket() {
      var _this2 = this;

      setTimeout(function () {
        _this2.queries = -1;
        _this2.drainQueue();
      }, _defaults2['default'].bucketDuration);

      this.queries = 0;
    }

    /**
     * Geocode the first `queriesPerSecond` items from the queue
     **/
  }, {
    key: 'drainQueue',
    value: function drainQueue() {
      var _this3 = this;

      this.queue.splice(0, this.queriesPerSecond).forEach(function (query) {
        _this3.queueGeocode.apply(_this3, _toConsumableArray(query));
      });
    }

    /**
     * Start geocoding a single address
     * @param {String} address The address to geocode
     * @param {Function} resolve The Promise resolve function
     * @param {Function} reject The Promise reject function
     * @param {Number} retries The number of times this query has been tried
     */
  }, {
    key: 'startGeocode',
    value: function startGeocode(address, resolve, reject) {
      var _this4 = this;

      var retries = arguments.length <= 3 || arguments[3] === undefined ? 0 : arguments[3];

      var geoCodeParams = {
        address: address.replace('\'', '')
      };

      this.geocoder.geocode(geoCodeParams, function (error, response) {
        if (error) {
          var errorMessage = _errors2['default'][error.code] || 'Google Maps API error: ' + error.code;

          return reject(new Error(errorMessage));
        }

        if (response.status === 'OVER_QUERY_LIMIT') {
          if (retries >= _this4.maxRetries) {
            return reject(new Error('Over query limit'));
          }

          return _this4.queueGeocode(address, resolve, reject, retries + 1);
        }

        if ((0, _ampIsEmpty2['default'])(response.results)) {
          return reject(new Error('No results found'));
        }

        var results = response.results;

        _this4.cache.add(address, results);
        return resolve(results);
      });
    }
  }]);

  return Geocoder;
})();

exports['default'] = Geocoder;
module.exports = exports['default'];