'use strict';

Object.defineProperty(exports, '__esModule', {
  value: true
});

var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

var _get = function get(_x3, _x4, _x5) { var _again = true; _function: while (_again) { var object = _x3, property = _x4, receiver = _x5; _again = false; if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { _x3 = parent; _x4 = property; _x5 = receiver; _again = true; desc = parent = undefined; continue _function; } } else if ('value' in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } } };

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }

function _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var _stream = require('stream');

var _stream2 = _interopRequireDefault(_stream);

var _cyclist = require('cyclist');

var _cyclist2 = _interopRequireDefault(_cyclist);

/**
 * ParallelTransform instance
 * All child classes must implement the `_parallelTransform` function.
 * Child class should not implement the `_transform` and `_flush` functions.
 *
 * @param {Number} maxParallel The maximum number of
 *                             simulatenous transformations
 * @param {Object} options Options which will be passed
 *                         to the `stream.Transform` constructor
 **/

var ParallelTransform = (function (_stream$Transform) {
  _inherits(ParallelTransform, _stream$Transform);

  function ParallelTransform() {
    var maxParallel = arguments.length <= 0 || arguments[0] === undefined ? 1 : arguments[0];
    var options = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];

    _classCallCheck(this, ParallelTransform);

    options.highWaterMark = options.highWaterMark || Math.max(maxParallel, 16);

    _get(Object.getPrototypeOf(ParallelTransform.prototype), 'constructor', this).call(this, options);

    this.maxParallel = maxParallel;
    this.destroyed = false;
    this.flushed = false;
    this.buffer = (0, _cyclist2['default'])(maxParallel);
    this.top = 0;
    this.bottom = 0;
    this.ondrain = null;
  }

  /**
   * Destroys the stream
   * The results of all pending transformations will be discarded
   **/

  _createClass(ParallelTransform, [{
    key: 'destroy',
    value: function destroy() {
      if (this.destroyed) {
        return;
      }

      this.destroyed = true;
      this.emit('close');
    }

    /**
     * Called for every item in the stream
     * @param {?} chunk The chunk of data to be transformed
     * @param {String} enc Encoding, if it `chunk` is a string
     * @param {Function} done Callback to be called when finished
     * @return {?} Something to get out
     **/
  }, {
    key: '_transform',
    value: function _transform(chunk, enc, done) {
      var _this = this;

      var pos = this.top++;

      this._parallelTransform(chunk, function (err, data) {
        // eslint-disable-line no-underscore-dangle, max-len
        if (_this.destroyed) {
          return;
        }

        // abort on error
        if (err) {
          _this.emit('error', err);
          _this.push(null);
          _this.destroy();
          return;
        }

        // insert result into corresponding place in buffer
        var result = typeof data === 'undefined' || data === null ? null : data;
        _this.buffer.put(pos, result);

        // attempt to drain the buffer
        _this.drain();
      });

      // immediatelly signal `done` if no more than `maxParallel` results buffered
      if (this.top - this.bottom < this.maxParallel) {
        return done();
      }

      // otherwise wait until a transformation finished
      this.ondrain = done;
      return null;
    }

    /**
     * The _transform method of the parallel transform stream
     * This method must be re-implemented by child classes
     * @param {?} data Data to be transformed
     * @param {Function} done Callback which must be executed
     *                        when transformations have finished
     **/
  }, {
    key: '_parallelTransform',
    value: function _parallelTransform(data, done) {
      // eslint-disable-line no-unused-vars
      throw new Error('Not implemented');
    }

    /**
     * Called when all items have been processed
     * @param {Function} done Callback to signify when done
     **/
  }, {
    key: '_flush',
    value: function _flush(done) {
      this.flushed = true;
      this.ondrain = done;
      this.drain();
    }

    /**
     * Fire the `data` event for buffered items, in order
     * The buffer will be cleared in such a way that the
     * order of the input items is preserved. This means that calling
     * `drain` does not necessarily clear the entire buffer, as it will
     * have to wait for further results if a transformation has not yet finished
     * This function should never be called from outside this class
     **/
  }, {
    key: 'drain',
    value: function drain() {
      // clear the buffer until we reach an item who's result has not yet arrived
      while (typeof this.buffer.get(this.bottom) !== 'undefined') {
        var data = this.buffer.del(this.bottom++);

        if (data === null) {
          continue;
        }

        this.push(data);
      }

      // call `ondrain` if the buffer is drained
      if (this.drained() && this.ondrain) {
        var ondrain = this.ondrain;
        this.ondrain = null;
        ondrain();
      }
    }

    /**
     * Checks whether or not the buffer is drained
     * While receiving chunks, the buffer counts as drained as soon as
     * no more than `maxParallel` items are buffered.
     * When the stream is being flushed, the buffer counts as drained
     * if and only if it is entirely empty.
     * @return {Boolean} true if drained
     **/
  }, {
    key: 'drained',
    value: function drained() {
      var diff = this.top - this.bottom;
      return this.flushed ? !diff : diff < this.maxParallel;
    }
  }]);

  return ParallelTransform;
})(_stream2['default'].Transform);

exports['default'] = ParallelTransform;
module.exports = exports['default'];