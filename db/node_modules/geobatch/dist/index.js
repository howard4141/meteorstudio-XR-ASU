/* eslint-disable one-var */

'use strict';

Object.defineProperty(exports, '__esModule', {
  value: true
});

var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }

var _intoStream = require('into-stream');

var _intoStream2 = _interopRequireDefault(_intoStream);

var _geocoder = require('./geocoder');

var _geocoder2 = _interopRequireDefault(_geocoder);

var _geocodeStream = require('./geocode-stream');

var _geocodeStream2 = _interopRequireDefault(_geocodeStream);

var _stream = require('stream');

var _stream2 = _interopRequireDefault(_stream);

var _defaults = require('./defaults');

var _defaults2 = _interopRequireDefault(_defaults);

/**
 * GeoBatch instance
 * @type {Function}
 * @param {Object} options The options for the GeoBatch, default is
 *                         {cacheFile: 'geocache.db',
 *                           clientId: null,
 *                           privateKey: null}
 * @param {Object} Geocoder A geocoder.
 * @param {Object} GeocodeStream A GeocodeStream.
 */

var GeoBatch = (function () {
  function GeoBatch() {
    var Geocoder = arguments.length <= 1 || arguments[1] === undefined ? _geocoder2['default'] : arguments[1];

    var _ref = arguments.length <= 0 || arguments[0] === undefined ? {
      cacheFile: 'geocache.db',
      clientId: null,
      privateKey: null,
      apiKey: null,
      maxRetries: _defaults2['default'].maxRetries,
      queriesPerSecond: _defaults2['default'].defaultQueriesPerSecond,
      accessor: function accessor(address) {
        return address;
      }
    } : arguments[0];

    var _ref$cacheFile = _ref.cacheFile;
    var cacheFile = _ref$cacheFile === undefined ? 'geocache.db' : _ref$cacheFile;
    var _ref$clientId = _ref.clientId;
    var clientId = _ref$clientId === undefined ? null : _ref$clientId;
    var _ref$privateKey = _ref.privateKey;
    var privateKey = _ref$privateKey === undefined ? null : _ref$privateKey;
    var _ref$apiKey = _ref.apiKey;
    var apiKey = _ref$apiKey === undefined ? null : _ref$apiKey;
    var _ref$maxRetries = _ref.maxRetries;
    var maxRetries = _ref$maxRetries === undefined ? _defaults2['default'].maxRetries : _ref$maxRetries;
    var _ref$queriesPerSecond = _ref.queriesPerSecond;
    var queriesPerSecond = _ref$queriesPerSecond === undefined ? _defaults2['default'].defaultQueriesPerSecond : _ref$queriesPerSecond;
    var _ref$accessor = _ref.accessor;
    var accessor = _ref$accessor === undefined ? function (address) {
      return address;
    } : _ref$accessor;
    var GeocodeStream = arguments.length <= 2 || arguments[2] === undefined ? _geocodeStream2['default'] : arguments[2];

    _classCallCheck(this, GeoBatch);

    this.geocoder = new Geocoder({
      cacheFile: cacheFile,
      clientId: clientId,
      privateKey: privateKey,
      apiKey: apiKey,
      maxRetries: maxRetries,
      queriesPerSecond: queriesPerSecond
    });
    this.GeocodeStream = GeocodeStream;
    this.accessor = accessor;
    this.queriesPerSecond = queriesPerSecond;
  }

  /**
   * Geocode the passed in addresses
   * @param {Array/Stream} addresses The addresses to geocode
   * @return {Function} The stream
   */

  _createClass(GeoBatch, [{
    key: 'geocode',
    value: function geocode(addresses) {
      // If input is already stream, pass through directly.
      if (addresses instanceof _stream2['default']) {
        return this.geocodeStream(addresses);
      }

      var arrayStream = _intoStream2['default'].obj(addresses),
          stats = {
        total: addresses.length,
        current: 0,
        startTime: new Date()
      };

      return this.geocodeStream(arrayStream, stats);
    }

    /**
     * Geocode the elements of a passed in stream.
     * @param  {Stream} inputStream An input stream
     * @param  {Object} stats  An object with the stream stats, defaults to {}.
     * @return {Stream}        A transformable stream.
     */
  }, {
    key: 'geocodeStream',
    value: function geocodeStream(inputStream) {
      var stats = arguments.length <= 1 || arguments[1] === undefined ? { current: 0 } : arguments[1];

      var geocodeStream = new this.GeocodeStream(this.geocoder, this.queriesPerSecond, stats, this.accessor);
      inputStream.pipe(geocodeStream);

      return geocodeStream;
    }
  }]);

  return GeoBatch;
})();

exports['default'] = GeoBatch;
module.exports = exports['default'];